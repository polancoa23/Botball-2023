#include <kipr/wombat.h>
#include <stdlib.h>
#include <math.h>
//232.5 ticks per inch
// 40/3 ticks per degree
// 90 degrees is 1200 ticks
// sweeper should be on right side before it runs into red 
// sweeper should be on left side before it runs into green
// sweeper moves to the left when it sorts red
//sweeper moves to the right when it sorts green
// 6 normal
// 2 stacked
//white = 1170
//black = 2415
//distance: 1) white: 2160 2)1980 3) red: 2540 4) green: 2510 5) green top: 2900 6) red top: 2900

//VARIABLES
int lmotor = 1;
int rmotor = 0;
int sweeper = 0;
int grabber = 1;
int lineSense = 1;
int close = 200;
int open = 1020;
int left = 470;
int right = 1350;
int middle = 910;
int gray = 1793; 
int count = 0;
int pomSense = 0;

//FUNCTIONS
void drive(int distance, int speed);
void drive_b(int distance, int speed);
void drive_on(int distance, int speed);
void drive_off(int distance, int speed);
void right_turn(int distance, int speed);
void left_turn(int distance, int speed);
void line_follow(int distance, int speed, int port);
void servo(int port, int position, float speed);

int main()
{
    enable_servos();
    // start w/ sweeper in the middle and the robot at an angle so it could get the green and red pom all at once
    
    //STEP 1: get ring stand out the way
    drive_on(5000,500); // first param dont matter cuz its gonna keep going till it reaches the black line
    drive_off(5000,500); // same case, but instead its gonna keep going till its off the black line
    drive(349,500); // raised this number so it could be more on the left side of tape after right turn
    servo(sweeper,right,1);
    right_turn(933,1000);
    drive(930,-500);
    
    //STEP 2: pom collection and sorting
    while(count <= 8){
        line_follow(5000,500,lineSense);
        count++;
        printf("count = %d", count);
        if(count ==7){ // green top
            servo(grabber,close,2);
            servo(sweeper,left,2);
            servo(grabber,open,2);
        }
        if(count == 8){ // red top
            servo(grabber,close,2);
            servo(sweeper,right,2);
            servo(grabber,open,2);
        }
        if(count%2 > 0 && count < 7){ // red
            servo(sweeper,left,2);
        }
        if(count%2 == 0 && count < 7){ // green
            servo(sweeper,right,2);
        }
    }
    
     


    ao();
    disable_servos();
    return 0;
}
void drive(int distance, int speed){
    cmpc(0);
    while(abs(gmpc(0)) < distance){
        mav(0,speed);
        mav(1,speed); 
    }
    mav(0,0);
    mav(1,0);
    msleep(20);
}
void drive_b(int distance, int speed){
    cmpc(0);
    while(abs(gmpc(0)) < distance){
        mav(0,speed - 150);
        mav(1,speed); 
    }
    mav(0,0);
    mav(1,0);
    msleep(20);
}
void drive_on(int distance, int speed){
    cmpc(0);
    while(abs(gmpc(0)) < distance){
        if(analog(lineSense) > 2000){
            break;
        }
        mav(0,speed);
        mav(1,speed); 
    }
    mav(0,0);
    mav(1,0);
    msleep(20);
}
void drive_off(int distance, int speed){
    cmpc(0);
    while(abs(gmpc(0)) < distance){
        if(analog(lineSense) < 1200){
            break;
        }
        mav(0,speed);
        mav(1,speed); 
    }
    mav(0,0);
    mav(1,0);
    msleep(20);
}
void right_turn(int distance, int speed){
    cmpc(1);
    while(gmpc(1) < distance){
        mav(0,-speed);
        mav(1,speed);
    }
    mav(0,0);
    mav(1,0);
    msleep(20);
}
void left_turn(int distance, int speed){
    cmpc(0);
    while(gmpc(0) < distance){
        mav(0,speed);
        mav(1,-speed);
    }
    mav(0,0);
    mav(1,0);
    msleep(20);
}
void line_follow(int distance, int speed, int port){
    cmpc(0);
    while(abs(gmpc(0)) < distance){
        if(analog(pomSense) > 2500){
            break;
        }
        int error = analog(port) - gray; //error > 0 = black. error < 0 = white. this constant is calculated by (white board val + black tape val)/2
        float speed_modifier = error * 0.025; // this constant needs adjustment. gray and white val difference. lower if change is too high. higher if change is too low. 0.02-0.1. had it at 0.025. ima change it to 0.035 to see how much it affects it
        mav(0,speed - speed_modifier); // had this as +. ima change it to - to see how it affects the line follow
        mav(1, speed + speed_modifier);// had this as -. ima change it to + to see how it affects the line follow
    }
    mav(0,0);
    mav(1,0);
    msleep(20);
}
void servo(int port, int position, float speed){ // speed is based off time so it's more consistent.
    float start_time = seconds(); // seconds is the # of seconds since a certain date and time, but it also measures in milliseconds. decimals are in milliseconds
    int start_position = get_servo_position(port);
    int position_difference = position-start_position; // gives us the direction we wanna travel. if pos > start_pos, it will give + direction. if pos < start_pos, it will give - direction.
    while(seconds()-start_time < speed){// time elapsed since start of function. seconds will keep increasing while start time doesn't
        float position_modifier = (seconds()-start_time)/speed;//Goes from 0 to 1. seconds - start_time is just time since loop started. speed is how long we want it to take
        set_servo_position(port, start_position+(position_difference*position_modifier)); // it's adding a lil each time  it loops
    }
    set_servo_position(port,position);
    msleep(50);
}
//easings.net shows how to create different functions to implement into servos. easeInOutCubic is nice to speed up and slow down.
